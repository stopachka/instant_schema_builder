import * as instatx from "./instatx";
import * as uuid from "uuid";

let _GLOBAL_CONFIG = null;
export type Config = {
  appId: string;
  adminToken: string;
  apiURI: string;
};

function assert(condition: any, msg?: string): asserts condition {
  if (!condition) {
    throw new Error("[assertion error] " + msg);
  }
}

function authorizedHeaders(config: Config) {
  const { adminToken, appId } = config;
  return {
    "content-type": "application/json",
    "authorization": `Bearer ${adminToken}`,
    "app-id": appId
  }
}

async function jsonFetch(
  input: RequestInfo,
  init: RequestInit | undefined
): Promise<any> {
  const res = await fetch(input, init);
  const json = await res.json();
  return res.status === 200
    ? Promise.resolve(json)
    : Promise.reject({ status: res.status, body: json });
}

function getConfig(): Config {
  assert(
    _GLOBAL_CONFIG,
    "Uh oh! Looks like `init` hasn't run yet. Make sure `init` runs " +
    "before your first `query` or `transact`.",
  );
  return _GLOBAL_CONFIG;
}

export function init(config: Config) {
  _GLOBAL_CONFIG = config;
}

export function query(query: string): Promise<any> {
  const config = getConfig();
  return jsonFetch(`${config.apiURI}/admin/query`, {
    method: "POST",
    headers: authorizedHeaders(config),
    body: JSON.stringify({ 'query': query }),
  });
}

export function transact(inputChunks: instatx.TransactionChunk | instatx.TransactionChunk[],
) {
  const config = getConfig();
  const chunks = Array.isArray(inputChunks) ? inputChunks : [inputChunks];
  const steps = chunks.flatMap((tx) => instatx.getOps(tx));
  return jsonFetch(`${config.apiURI}/admin/transact`, {
    method: "POST",
    headers: authorizedHeaders(config),
    body: JSON.stringify({ 'steps': steps }),
  });
}

export const id = uuid.v4;
export const tx = instatx.tx;
